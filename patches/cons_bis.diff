Index: RewritingOrdinalSequence.v
===================================================================
--- RewritingOrdinalSequence.v	(revision 192)
+++ RewritingOrdinalSequence.v	(working copy)
@@ -97,9 +97,10 @@
    TODO: shouldn't Cons actually ask for bisimilarity?
    | Cons  : forall `(r : s ->> t, p : u [>] v), t [=] u -> s ->> v
 *)
+(* We could also include the length in the type *)
 Inductive sequence : term -> term -> Type :=
   | Nil   : forall t, t ->> t
-  | Cons  : forall `(r : s ->> t, p : t [>] u), s ->> u
+  | Cons  : forall `(r : s ->> t, p : u [>] v), t [=] u -> s ->> v
   | Lim   : forall s t, (nat -> { t' : term & s ->> t' }) -> s ->> t
 where "s ->> t" := (sequence s t).
 
@@ -111,7 +112,7 @@
 Reset sequence_rect.
 
 Notation "s ->> t" := (sequence s t).
-Implicit Arguments Cons [s t u].
+(*Implicit Arguments Cons [s t u].*)
 
 Section InductionPrinciple.
 
@@ -120,9 +121,9 @@
 Hypothesis H1 : forall t, P (Nil t).
 
 Hypothesis H2 :
-  forall `(r : s ->> t, p : t [>] u),
+  forall `(r : s ->> t, p : u [>] v, H : t [=] u),
     P r ->
-    P (Cons r p).
+    P (Cons r p H).
 
 Hypothesis H3 :
   forall s t (f : nat -> {t' : term &  s ->> t'}),
@@ -131,9 +132,9 @@
 
 Fixpoint sequence_rect `(r : s ->> t) : P r :=
   match r return P r with
-  | Nil t          => H1 t
-  | Cons s t r u p => H2 p (sequence_rect r)
-  | Lim s t f      => H3 t f (fun n => sequence_rect (|f n|))
+  | Nil t              => H1 t
+  | Cons s t r u v p H => H2 p H (sequence_rect r)
+  | Lim s t f          => H3 t f (fun n => sequence_rect (|f n|))
   end.
 
 End InductionPrinciple.
@@ -143,41 +144,41 @@
 
 Fixpoint length `(r : s ->> t) : ord' :=
   match r with
-  | Nil _          => Zero
-  | Cons _ _ r _ _ => Succ (length r)
-  | Lim _ _ f      => Limit (fun n => length (|f n|))
+  | Nil _              => Zero
+  | Cons _ _ r _ _ _ _ => Succ (length r)
+  | Lim _ _ f          => Limit (fun n => length (|f n|))
   end.
 
 Fixpoint pref_type `(r : s ->> t) : Type :=
   match r with
-  | Nil _          => False
-  | Cons _ _ r _ _ => (unit + pref_type r) % type
-  | Lim _ _ f      => { n : nat & pref_type (|f n|) }
+  | Nil _              => False
+  | Cons _ _ r _ _ _ _ => (unit + pref_type r) % type
+  | Lim _ _ f          => { n : nat & pref_type (|f n|) }
   end.
 
 Fixpoint pref `(r : s ->> t) : pref_type r -> { t' : term & s ->> t' } :=
   match r in s ->> t return pref_type r -> { t' : term & s ->> t' } with
-  | Nil _           => !
-  | Cons s t' q _ _ => fun i => match i with
-                                | inl tt => existT (fun u => s ->> u) t' q
-                                | inr j  => pref q j
-                                end
-  | Lim _ _ f       => fun i => match i with
-                                | existT n j => pref (|f n|) j
-                                end
+  | Nil _               => !
+  | Cons s t' q _ _ _ _ => fun i => match i with
+                                    | inl tt => existT (fun u => s ->> u) t' q
+                                    | inr j  => pref q j
+                                    end
+  | Lim _ _ f           => fun i => match i with
+                                    | existT n j => pref (|f n|) j
+                                    end
   end.
 
 (* maybe this could be a coercion *)
 Fixpoint pref_type_as_pred_type `(r : s ->> t) : pref_type r -> pred_type (length r) :=
   match r in s ->> t return pref_type r -> pred_type (length r) with
-  | Nil _          => !
-  | Cons _ _ q _ _ => fun i => match i with
-                               | inl tt => inl _ tt
-                               | inr j  => inr _ (pref_type_as_pred_type q j)
-                               end
-  | Lim _ _ f      => fun i => match i with
-                               | existT n j => existT _ n (pref_type_as_pred_type (|f n|) j)
-                               end
+  | Nil _              => !
+  | Cons _ _ q _ _ _ _ => fun i => match i with
+                                   | inl tt => inl _ tt
+                                   | inr j  => inr _ (pref_type_as_pred_type q j)
+                                   end
+  | Lim _ _ f          => fun i => match i with
+                                   | existT n j => existT _ n (pref_type_as_pred_type (|f n|) j)
+                                   end
   end.
 
 Implicit Arguments pref_type_as_pred_type [s t r].
@@ -187,7 +188,7 @@
     length (|pref r i|) = pred (length r) (pref_type_as_pred_type i).
 Proof.
 intros s t r i.
-induction r as [t| s t r u p IH | s t f IH ].
+induction r as [t| s t r u v p H IH | s t f IH ].
 elim i.
 destruct i as [[] | i].
 reflexivity.
@@ -198,14 +199,14 @@
 
 Fixpoint pred_type_as_pref_type `(r : s ->> t) : pred_type (length r) -> pref_type r :=
   match r in s ->> t return pred_type (length r) -> pref_type r with
-  | Nil _          => !
-  | Cons _ _ q _ _ => fun i => match i with
-                               | inl tt => inl _ tt
-                               | inr j  => inr _ (pred_type_as_pref_type q j)
-                               end
-  | Lim _ _ f      => fun i => match i with
-                               | existT n j => existT _ n (pred_type_as_pref_type (|f n|) j)
-                               end
+  | Nil _              => !
+  | Cons _ _ q _ _ _ _ => fun i => match i with
+                                   | inl tt => inl _ tt
+                                   | inr j  => inr _ (pred_type_as_pref_type q j)
+                                   end
+  | Lim _ _ f          => fun i => match i with
+                                   | existT n j => existT _ n (pred_type_as_pref_type (|f n|) j)
+                                   end
   end.
 
 Implicit Arguments pred_type_as_pref_type [s t r].
@@ -215,7 +216,7 @@
     length (|pref r (pred_type_as_pref_type i)|) = pred (length r) i.
 Proof.
 intros s t r i.
-induction r as [t| s t r u p IH | s t f IH].
+induction r as [t| s t r u v p H IH | s t f IH].
 elim i.
 destruct i as [[] | i]; simpl.
 reflexivity.
@@ -229,7 +230,7 @@
     i = pred_type_as_pref_type (pref_type_as_pred_type i).
 Proof.
 intros s t r i.
-induction r as [t| s t r u p IH | s t f IH].
+induction r as [t| s t r u v p H IH | s t f IH].
 elim i.
 destruct i as [[] | i]; simpl; [| rewrite <- (IH i)]; reflexivity.
 destruct i as [n i]; simpl.
@@ -241,9 +242,9 @@
 Inductive length_le : forall `(r : s ->> t, q : u ->> v), Prop :=
   | Length_le_Nil  : forall s `(q : u ->> v),
                        Nil s <= q
-  | Length_le_Cons : forall `(r : s ->> t, q : u ->> v, p : t [>] w) i,
+  | Length_le_Cons : forall `(r : s ->> t, q : u ->> v, p : w [>] x, H : t [=] w) i,
                        r <= (|pref q i|) ->
-                       Cons r p <= q
+                       Cons r p H <= q
   | Length_le_Lim  : forall `(f : (nat -> { t' : term & s ->> t' }), q : u ->> v) t,
                        (forall n, (|f n|) <= q) ->
                        Lim t f <= q
@@ -257,29 +258,29 @@
   forall `(r : s ->> t, q : u ->> v),
     r <= q <-> length r <=' length q.
 Proof.
-induction r as [t| s t r u p IH | s t f IH]; simpl; split; intro H.
+induction r as [t| s t r u v p H IH | s t f IH]; simpl; split; intro H1.
 constructor.
 constructor.
-dependent destruction H.
+dependent destruction H1.
 apply Ord'_le_Succ with (pref_type_as_pred_type i).
 rewrite <- pref_type_as_pred_type_ok.
-apply (IH u ($ pref q i $) (| pref q i |)). (* apply IH. *)
+apply (IH u0 ($ pref q i $) (| pref q i |)). (* apply IH. *)
 assumption.
-inversion_clear H.
+inversion_clear H1.
 apply Length_le_Cons with (pred_type_as_pref_type i).
 apply (IH u0 ($ pref q (pred_type_as_pref_type i) $) (| pref q (pred_type_as_pref_type i) |)). (* apply IH. *)
 rewrite <- pred_type_as_pref_type_ok in H0.
 assumption.
-dependent destruction H.
+dependent destruction H1.
 constructor.
 intro n.
 apply (IH n u v q). (* apply IH. *)
 apply H.
-inversion_clear H.
+inversion_clear H1.
 constructor.
 intro n.
 apply (IH n u v q). (* apply IH. *)
-apply H0.
+apply H.
 Qed.
 
 Lemma length_le_refl :
@@ -347,7 +348,7 @@
 destruct i as [[] | i]; simpl in j |- *.
 exists (inr _ j).
 reflexivity.
-destruct (IHr i j) as [k H].
+destruct (IHr i j) as [k H1].
 exists (inr _ k).
 assumption.
 destruct i as [n i]; simpl in j |- *.
@@ -378,9 +379,9 @@
 *)
 Fixpoint good `(r : s ->> t) : Prop :=
   match r with
-  | Nil _          => True
-  | Cons _ _ q _ _ => good q
-  | Lim _ t f      =>
+  | Nil _              => True
+  | Cons _ _ q _ _ _ _ => good q
+  | Lim _ t f          =>
     (forall n, good (|f n|)) /\
     forall n m, (n < m)%nat -> prefix (|f n|) (|f m|)
   end.
@@ -413,9 +414,9 @@
 Fixpoint weakly_convergent `(r : s ->> t) : Prop :=
   good r /\
   match r with
-  | Nil _          => True
-  | Cons _ _ q _ _ => weakly_convergent q
-  | Lim _ t f      =>
+  | Nil _              => True
+  | Cons _ _ q _ _ _ _ => weakly_convergent q
+  | Lim _ t f          =>
     (forall n, weakly_convergent (|f n|)) /\
     forall d, exists n, forall m, (n < m)%nat -> forall i,
       (|f n|) <= (|pref (|f m|) i|) ->
@@ -424,17 +425,17 @@
 
 Definition last_step_below d `(r : s ->> t) : Prop :=
   match r with
-  | Cons _ _ _ _ p => (depth p > d)%nat
-  | _              => True
+  | Cons _ _ _ _ _ p _ => (depth p > d)%nat
+  | _                  => True
   end.
 
 (* TODO: is this strong convergence? *)
 Fixpoint strongly_convergent `(r : s ->> t) : Prop :=
   weakly_convergent r /\
   match r with
-  | Nil _          => True
-  | Cons _ _ q _ _ => strongly_convergent q
-  | Lim _ t f      =>
+  | Nil _              => True
+  | Cons _ _ q _ _ _ _ => strongly_convergent q
+  | Lim _ t f          =>
     (forall n, strongly_convergent (|f n|)) /\
     forall d, exists n, forall m, (n < m)%nat -> forall i,
       (|f n|) <= (|pref (|f m|) i|) ->
@@ -454,9 +455,9 @@
 (* yes we can *)
 Fixpoint append_rec (s t u : term) (q : t ->> u) : s ->> t -> s ->> u :=
   match q in t ->> u return s ->> t -> s ->> u with
-  | Nil t0         => fun r => r
-  | Cons _ _ q _ p => fun r => Cons (append_rec q r) p
-  | Lim _ u f      => fun r => Lim u (fun o => existT (fun u => s ->> u) ($ f o $) (append_rec (|f o|) r))
+  | Nil t0             => fun r => r
+  | Cons _ _ q _ _ p H => fun r => Cons (append_rec q r) p H
+  | Lim _ u f          => fun r => Lim u (fun o => existT (fun u => s ->> u) ($ f o $) (append_rec (|f o|) r))
   end.
 
 Definition append `(r : s ->> t, q : t ->> u) : s ->> u := append_rec q r.
@@ -465,7 +466,7 @@
   forall `(r : s ->> t, q : t ->> u),
     length (append r q) ==' add (length r) (length q).
 Proof.
-induction q as [u| t u q v p IH | t u f IH]; simpl.
+induction q as [u | t u q v w p H IH | t u f IH]; simpl.
 apply ord'_eq_refl.
 split.
 apply Ord'_le_Succ with (inl (pred_type (add (length r) (length q))) tt).
@@ -540,7 +541,7 @@
       length r' <=' Omega.
 Proof.
 intros LL s t r SC.
-induction r as [t | s t r u p IH | s t f IH].
+induction r as [t | s t r u v p H IH | s t f IH].
 
 (* Case (Nil t) *)
 exists (Nil t).
@@ -551,8 +552,8 @@
 (* Case (Cons r p) *)
 assert (IH' := (IH (proj2 SC))); clear r SC IH.
 destruct IH' as [r [SC IH]].
-destruct (ord'_le_omega_elim IH) as [[i H] | H]; clear IH.
-exists (Cons r p).
+destruct (ord'_le_omega_elim IH) as [[i Hl] | Hl]; clear IH.
+exists (Cons r p H).
 split.
 admit. (* apply SCr'. *)
 apply Ord'_le_Succ with i.
Index: Examples.v
===================================================================
--- Examples.v	(revision 192)
+++ Examples.v	(working copy)
@@ -196,8 +196,11 @@
 dependent destruction i.
 Defined.
 
+(* Proof that t is bisimilar to t, for any term t *)
+Definition t_eq {t} := @term_eq_refl F X t.
+
 (* Single-step reduction A ->> B(A) *)
-Definition s_A_BA : (A!) ->> (B @ A!) := Cons s_A p_A_BA.
+Definition s_A_BA : (A!) ->> (B @ A!) := Cons s_A p_A_BA t_eq.
 
 (* Step B(A) -> B(B(A)) *)
 Program Definition p_BA_BBA : (B @ A!) [>] (B @ B @ A!) := Step ABA (B @@@ Hole) id_sub ABA_in.
@@ -230,7 +233,7 @@
 Defined.
 
 (* Two-step reduction A ->> B(B(A)) *)
-Definition s_A_BBA : (A!) ->> (B @ B @ A!) := Cons s_A_BA p_BA_BBA.
+Definition s_A_BBA : (A!) ->> (B @ B @ A!) := Cons s_A_BA p_BA_BBA t_eq.
 
 (* B(B(...(A)...)) with n applications of B *)
 Fixpoint nB_A (n : nat) : term :=
@@ -293,7 +296,7 @@
 Fixpoint s_A_nBA (n : nat) : (A!) ->> (nB_A n) :=
   match n as m in nat return (A!) ->> (nB_A m) with
   | 0   => Nil (A!)
-  | S n => Cons (s_A_nBA n) (p_nBA_nBBA n)
+  | S n => Cons (s_A_nBA n) (p_nBA_nBBA n) t_eq
   end.
 
 (* s_A_nBA but with Sigma return type including right-most term *)
@@ -316,11 +319,11 @@
 induction n; simpl; trivial.
 intros n m H.
 induction H; simpl.
-change (prefix (|pref (Cons (s_A_nBA n) (p_nBA_nBBA n)) (inl _ tt)|) (Cons (s_A_nBA n) (p_nBA_nBBA n))).
+change (prefix (|pref (Cons (s_A_nBA n) (p_nBA_nBBA n) t_eq) (inl _ tt)|) (Cons (s_A_nBA n) (p_nBA_nBBA n) t_eq)).
 constructor.
 apply prefix_trans with _ (s_A_nBA m).
 assumption.
-change (prefix (|pref (Cons (s_A_nBA m) (p_nBA_nBBA m)) (inl _ tt)|) (Cons (s_A_nBA m) (p_nBA_nBBA m))).
+change (prefix (|pref (Cons (s_A_nBA m) (p_nBA_nBBA m) t_eq) (inl _ tt)|) (Cons (s_A_nBA m) (p_nBA_nBBA m) t_eq)).
 constructor.
 Qed.
 
